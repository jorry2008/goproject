package chapter1

import "fmt"

// 定义一个全局函数
var (
	// Fun1 就是一个全局匿名函数
	Fun1 = func(n1 int, n2 int) int {
		return n1 * n2
	}
)

// init()方法可以不需要，如果有 init() 函数则会先执行该函数，init() 方法不可以有参数，也不可以有返回
func init() {
	fmt.Println("初始化函数")
}

// Example3 局部声明或者初始中 := 操作很常用，也很方便
func Example8888() {
	println("Example888:")
	// 空白标识符，是一个只写变量，你不能得到它的值，正因为这种特性，空白标识符可用于接受多余的值并执行了初始化，但又可以不在当前作用域下使用，从而避免了错误（局部声明变量不使用报错的问题！！）
	// 空白标识符用来人为抛弃数据，又不至于触发语法错误（语法规则是：在方法体中声明的所有变量必须要使用，函数返回的所有值必须要接收，否则都将报错）
	_, numb, strs := numbers() //只获取函数返回值的后两个
	println(numb, strs)
	print("使用变量，调用全局匿名函数，结果：")
	println(Fun1(25, 25))

	// 调用内部私有方法
	// 调用外部公有方法
}

// 一个可以返回多个值的函数
func numbers() (int, int, string) {
	a, b, c := 1, 2, "str"
	return a, b, c
}

// 整个 Go 程序只分内外两种访问类型，大写开头的对外部包（包内和包外）可访问（公有），小写开头的对内部包（所有同包下的文件都可访问）访问（私有）
// 所以我们会发现，在程序中，大写开头的属性和方法全是外部外引入进来的，所有小写开头的属性和方法都是当前包的（注意：是以包为分界线）
func other() {
	fmt.Println("其它私有main包方法")
}

// 符合大写公有、小写私有规则的还包括：常量、变量、类型、函数名、结构字段
// 什么叫隐式包，具体如何操作？

func Other() {
	fmt.Println("其它公共main包方法")
}

// 一个文件夹下最多只能有一个包，包名可与文件夹相同，也可以不同，引入操作上会有一些差异

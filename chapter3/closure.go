package chapter3

import "fmt"

// 闭包是针对运行环境中匿名函数内部被引用的变量而言的概念
// 闭包就是匿名函数内部的变量被 hold 住的一种现象
// 闭包的特性可以加以利用，创造一些特殊的功能，比如 工厂模式，特别是在 js 中，闭包的特性非常重要

/*
闭包是个非常灵活的特性：（它在不同语言中的表现）
闭包（Closure）在 Java 编程语言中也被称为 Lambda 表达式，这种表达的连续操作性非常优雅
闭包对环境中变量的引用过程也可以被称为“捕获”，在 C++11 标准中，捕获有两种类型，分别是引用和复制，可以改变引用的原值叫做“引用捕获”，捕获的过程值被复制到闭包中使用叫做“复制捕获”
在 Lua 语言中，将被捕获的变量起了一个名字叫做 Upvalue，因为捕获过程总是对闭包上方定义过的自由变量进行引用
C++ 与 C# 中为闭包创建了一个类，而被捕获的变量在编译时放到类中的成员中，闭包在访问被捕获的变量时，实际上访问的是闭包隐藏类的成员（这种处理方式让闭包特性成了一个记忆载体）
*/

func Example005555() {
	fmt.Println("Example005555:")

	// 闭包的特性：
	// 一、修改引用变量
	str := "hello world"
	foo := func() {
		str = "hello dude" // 匿名函数中访问str（此时 str 为闭包状态，且是引用外部函数体中的 str）
	}
	foo()
	fmt.Println("原字符串被修改过了", str)

	// 二、闭包的记忆效应
	test := closureTest() // 这一步，直接在运行时，创建了闭包
	// 下面所有操作，都是对匿名函数的调用，且闭包变量 i 使用的是地址值，所以修改时会有记忆效应
	test()
	test()
	test()
}

// 在函数体中创建匿名函数，匿名函数体内调用了函数体中的变量，变量就形成了闭包
func closureTest() func() int {
	i := 0
	return func() int { // i 被定义在了匿名函数之前，i 在匿名函数中就形成了闭包
		i++
		return i
	}
}

// 闭包是一种现象，特性
// http://c.biancheng.net/view/59.html

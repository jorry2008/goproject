// Package chapter5 主要解释：go语言中的引用比较特殊，引用和指针之间的关系
package chapter5

import "fmt"

// 我们应该先了解引用的历史：（不一定是真的）
// 在最初的时候，c 语言只有指针特性，其过于接近底层，使用非常透明，容易出错不方便，
// 为了解决这个问题，基于指针增加了引用的特性（对指针的封装），
// 引用使用直观，不容易出错，使用方便，还能自动转化，是一种不透明指针，所以引用本来是一种对指针的增强或替补方案。

// 你以为的指针与引用是同一个东西，那是你以为的！
// 本质上讲，函数参数的所谓传值或传引用，在 php 和 go 语言中的行为其实是一样的！
// 差别在于 go 语言中直接支持指针类型，而 php 不支持，php 需要手动 & 出地址址，来产生一个伪引用（就是多支持了一个类型）

// 引用和指针 相似但不同！
// 区别一：
// 指针变量存储的是另一个变量的地址。
// 引用变量指向另外一个变量。

// 区别二：
// 对于指针，必须使用 * 操作符来解引用。
// 对于引用，不需要任何操作符。
// 因此，指针可以重分配，而引用不能。换句话说，指针可以被分配另一个不同的地址。（指针可以无限的分配新的内存来存储指针的指针...）

// go 语言中只有这几个类型有引用特性：slice、map、chan、func、interface

func Example5_4() {
	fmt.Println("Example5_4:")

	// 引用特性
	s1 := make([]int, 10, 20)

	fmt.Println(s1)
	func1(s1)
	fmt.Println(s1)

	// 指针特性
	cat1 := new(Cat1) // 等价 （var cat1 *Cat = new(Cat1)）
	cat1.Name = "Tom" // 隐式解引用
	fmt.Println(*cat1)

	v1 := new(int)
	*v1 = 15 // 值类型可直接基于 * 使用
}

func func1(s []int) { // 切片本身就是引用类型，所以函数内外相互影响，对于 s 而言，它就是拷贝一个值，只是这个值本身就是引用而已
	s[1] = 20
}

type Cat1 struct {
	Name string
	Age  int
}

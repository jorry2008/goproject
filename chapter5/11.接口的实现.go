package chapter5

import (
	"fmt"
	"log"
)

// 以下实例，解析一个问题：到底是接收器的什么类型实现了接口？
// 在非接口方法的绑定中，因为 go 语言的隐式自动类型转换，让我们不用去理会方法接收器的类型应该如何定义，按照自己的需求一定义即可。
// 在接口方法中，一个接口是否实现需要以下条件：
// 1.绑定了一个接口的所有方法列表；
// 2.如果所有方法接口收都是值类型，则调用者实例或实例的指针都实现了此接口（可以任意接口类型变量赋值）；如果所有方法中有至少一个方法的接收器是指针类型，则只能是调用者实例的指针实现了此接口；（背后逻辑，是寻址的问题，以下会讲到）

type Code interface {
	hello()
	world()
}

type ZQ struct{}

func (z ZQ) hello() {
	log.Println("hello")
}

func (z *ZQ) world() { // 接口方法的接收器是指针类型，所以 只有 &ZQ{} 类型实现了 Code 接口
	log.Println("world")
}

func print(z Code) {}

func Example5_11() {
	fmt.Println("Example5_11:")

	var qq Code // 接口引用类型

	// 一、向接口赋值，编译时错误
	//qq = ZQ{}
	//fmt.Println(qq) // cannot use ZQ{} (value of type ZQ) as type Code in assignment: ZQ does not implement Code (world method has pointer receiver)

	// 正常执行
	qq = &ZQ{}
	fmt.Println(qq)

	// 二、调用方法参数接口转换
	//print(ZQ{}) // 同上，编译错误
	print(&ZQ{})

	// 尝试解释这个问题：
	zMap := map[int]ZQ{1: ZQ{}}
	zMap[1].hello()
	//zMap[1].world() // 不可寻址，编译错误【值类型存储在集合中，无法实现集合元素直接寻址】

	zMap1 := map[int]*ZQ{1: &ZQ{}}
	zMap1[1].hello()
	zMap1[1].world()
	// 也就是说，ZQ{}被包裹在了接口类型 qq 中，它是不可寻址的，即无法从接口类型中qq中寻址ZQ{}，导致无法自动转换调用接口的指针接收器方法，因此在编译时就说明普通类型未实现接口

	// 进一步说明：
	// 什么时候不允许对指针寻址呢？答案很简单：空指针。（不可寻址的原因）

	zqNilPtr := (*ZQ)(nil) // 将空指针强制转换为 *ZQ
	zqNilPtr.world()       // 正常执行
	//zqNilPtr.hello()       // 编译错误 // panic: runtime error: invalid memory address or nil pointer dereference [signal 0xc0000005 code=0x0 addr=0x0 pc=0x433468]

	// 注意二者的区别，对于值类型来说，是编译时失败；对指针类型，是运行时恐慌。这就可以反向推测，Go 编译器认为：
	// 值类型只拥有值方法；
	// 指针类型拥有值方法和指针方法；
}

// 參考：https://blog.csdn.net/qq_41359051/article/details/104229649

// 重点总结：
/*
值类型接口收方法那么好用（会隐含地也实现了接收者是指针类型的方法），不挑调用者是什么类型（值类型/指针类型），两者使用的场景分别是什么：
如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者（每次调用都会有一个参数复制的过程）；
如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身；
那么，使用指针作为方法的接收者的理由：
方法能够修改接收者指向的值；
避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效；【指针本身就是高效的】

具体的选型：（针对接收器类型）
如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如 字符串、整型值、slice、map、interface、channel 等，那么接收器只需要定义为值类型，传递的过程中复制即可（其中也有包含基本引用类型，复制的也仅仅是地址值）。
如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义为指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。
*/

// 为什么有这种奇怪的不太好理解的特性？
/*
下面基于逻辑来梳理...
当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。
但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。
jorry解释：
以上过程，可以认为实现值类型接口方法，调用者可以是指针或值对象，反过来理解就是，实现了值类型接口方法时，隐含地也就实现了对应的指针类型接口方法！那么使用两种类型的调用者均可。原因是：设计者写的值类型接口方法本身对调用者并没有影响，而隐含实现的指针接口方法同样不会对调用者产生影响（由设计者的方法体决定），所以调用者是值类型或指针类型均可！
而实现指针类型接口方法，调用者只能是指针类型对象。原因是：设计者写的指针类型接口方法，其本意就是要改变调用者（不然他也没有必要使用指针接收器），而一个改变调用者的指针接收器方法，假设如果隐含有对应的值类型方法，而值类型只会产生一个拷贝，无法实现对调用者的改变！最后两种调用的结果会产生偏差！所以Go不支持此情况下的接口实现。

最后，记住：如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。
或者：接口方法中有指针接收者实现时，要保证接口类型转换，必须使用指针。(&struct{}或new(struct))
参考：https://golang.design/go-questions/interface/receiver/
*/

package chapter5

import "fmt"

// 有没有专门介绍 type 自定义类型的？
// 这种自定义类型同样也可绑定函数！他们与结构体一样，都是一种类型，且可以绑定方法
// 注意：任何类型都可以绑定方法，只是我们这里介绍将方法绑定到结构体中（除了基本类型以外）！！！！

type pArr []int // 我们无法在int类型上绑定方法，但可以使用 type 创建的类型来绑定方法

// 在Go语言中，将函数绑定到具体的类型中，则称该函数是该类型的方法，其定义的方式是在func与函数名称之间加上具体类型变量，这个类型变量称为方法接收器，如：
func (p *pArr) oopFunc() { //
	(*p)[3] = 111
}

func Example5_1() {
	fmt.Println("Example5_1:")

	// 类似面向对象的方法（这种风格非常具有面向对象特性）
	p := make(pArr, 4)
	p.oopFunc()
	fmt.Println("p:", p) //p: [0 0 0 111]
}

/*
以 type NewInt int64 举例，虽然它们共享同样的内存实现（8 个字节的连续内存），在基本运算符上有同样的结果，但是 NewInt 被认为是跟 int 不同的一个类型，可以拥有自己的方法。
两种类型不能直接一起运算，也不能用作另一种类型的参数，需要经过转换。

不直接使用原类型，而是定义命名的新类型，我认为有以下几个原因：
1.使用方便
这是对冗长的派生类型——尤其是 结构体 和 接口 而言的。简洁的名字当然比冗长的结构方便且不易出错。
2.自注释
名字可以体现用途和意图。
3.借用静态检查发现错误
将底层实现一样但是业务逻辑不一致的类型分别定义为不同的类型，可以借由静态检查发现逻辑错误。这在上一期类型转换部分，我用 砧板 和 地板 的 底层类型都是 木板 做了一个类比。【这里不是很清楚，需要研究】
4.添加方法
Go 可以（且只可以）给当前包定义的类型添加方法。
内置类型和导入类型定义成新类型之后，就可以给新类型添加方法，实现面向对象编程。

注意：
定义成新类型之后，原来类型的方法就全部丢失（只是类型结构，不包括方法），不能再访问了（毕竟已经不是同一个类型）。
如果需要保留原来的方法，应该选择将旧类型匿名嵌入新类型的结构体（类型组合，而且一定要使用匿名）。
匿名嵌入效果上接近继承，实际上是组合，只是跟一般成员组合相比，被匿名嵌入类型的成员和方法可以直接访问。
具体在 方法 和 结构体 部分展开。（这就实现了类型的完全继承了）
*/
